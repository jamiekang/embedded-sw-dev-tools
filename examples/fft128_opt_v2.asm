;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This is an implementation example for OFDM DSP.
; - Ver 0.4 - this is for dspsim ver 1.6+ 
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Note:
; This is an optimized version with multifunction instructions.
; All scaling operations implemented for precise fixed-point arithmetic.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    .DATA
	.VAR	x0[256]		; input array (complex pair)			- IWL:0 (0x000)
	.VAR	s1[256]		; stage 1 output (complex pair)			- IWL:1 (0x100)
	.VAR	s2[256]		; stage 2 output (complex pair)			- IWL:2 (0x200)
	.VAR	s3[256]		; stage 3 output (complex pair)			- IWL:3 (0x300)
	.VAR	s4[256]		; stage 4 output (complex pair)			- IWL:4 (0x400)
	.VAR	s5[256]		; stage 5 output (complex pair)			- IWL:5 (0x500)
	.VAR	s6[256]		; stage 6 output (complex pair)			- IWL:6 (0x600)
	.VAR	y[256]		; output array (complex pair)			- IWL:7 (0x700)
	.VAR	coeff[256]	; W(n)_128 FFT coeff. (complex pair)	- IWL:0 (0x800) - ** Note: we use only half of this table **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    .CODE	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialize Coefficients
	LD	I0, coeff		; Coeff. begin address
	LD	M0, 0x1
	NOP					; 1-clock delay needed for Ix/Mx register use
; autogenerated initializing code
	ST	DM(I0+=M0), 0x7FF		; Re of 1.000000	(Coeff.#0, IWL:0)
	ST	DM(I0+=M0), 0x000		; Im of 0.000000
	ST	DM(I0+=M0), 0x7FD		; Re of 0.998795	(Coeff.#1, IWL:0)
	ST	DM(I0+=M0), 0xF9C		; Im of -0.049068
	ST	DM(I0+=M0), 0x7F6		; Re of 0.995185	(Coeff.#2, IWL:0)
	ST	DM(I0+=M0), 0xF38		; Im of -0.098017
	ST	DM(I0+=M0), 0x7E9		; Re of 0.989177	(Coeff.#3, IWL:0)
	ST	DM(I0+=M0), 0xED4		; Im of -0.146730
	ST	DM(I0+=M0), 0x7D8		; Re of 0.980785	(Coeff.#4, IWL:0)
	ST	DM(I0+=M0), 0xE71		; Im of -0.195090
	ST	DM(I0+=M0), 0x7C2		; Re of 0.970031	(Coeff.#5, IWL:0)
	ST	DM(I0+=M0), 0xE0F		; Im of -0.242980
	ST	DM(I0+=M0), 0x7A7		; Re of 0.956940	(Coeff.#6, IWL:0)
	ST	DM(I0+=M0), 0xDAE		; Im of -0.290285
	ST	DM(I0+=M0), 0x788		; Re of 0.941544	(Coeff.#7, IWL:0)
	ST	DM(I0+=M0), 0xD4F		; Im of -0.336890
	ST	DM(I0+=M0), 0x764		; Re of 0.923880	(Coeff.#8, IWL:0)
	ST	DM(I0+=M0), 0xCF1		; Im of -0.382683
	ST	DM(I0+=M0), 0x73B		; Re of 0.903989	(Coeff.#9, IWL:0)
	ST	DM(I0+=M0), 0xC95		; Im of -0.427555
	ST	DM(I0+=M0), 0x70E		; Re of 0.881921	(Coeff.#10, IWL:0)
	ST	DM(I0+=M0), 0xC3B		; Im of -0.471397
	ST	DM(I0+=M0), 0x6DC		; Re of 0.857729	(Coeff.#11, IWL:0)
	ST	DM(I0+=M0), 0xBE4		; Im of -0.514103
	ST	DM(I0+=M0), 0x6A6		; Re of 0.831470	(Coeff.#12, IWL:0)
	ST	DM(I0+=M0), 0xB8F		; Im of -0.555570
	ST	DM(I0+=M0), 0x66C		; Re of 0.803208	(Coeff.#13, IWL:0)
	ST	DM(I0+=M0), 0xB3D		; Im of -0.595699
	ST	DM(I0+=M0), 0x62F		; Re of 0.773010	(Coeff.#14, IWL:0)
	ST	DM(I0+=M0), 0xAED		; Im of -0.634393
	ST	DM(I0+=M0), 0x5ED		; Re of 0.740951	(Coeff.#15, IWL:0)
	ST	DM(I0+=M0), 0xAA1		; Im of -0.671559
	ST	DM(I0+=M0), 0x5A8		; Re of 0.707107	(Coeff.#16, IWL:0)
	ST	DM(I0+=M0), 0xA58		; Im of -0.707107
	ST	DM(I0+=M0), 0x55F		; Re of 0.671559	(Coeff.#17, IWL:0)
	ST	DM(I0+=M0), 0xA13		; Im of -0.740951
	ST	DM(I0+=M0), 0x513		; Re of 0.634393	(Coeff.#18, IWL:0)
	ST	DM(I0+=M0), 0x9D1		; Im of -0.773010
	ST	DM(I0+=M0), 0x4C3		; Re of 0.595699	(Coeff.#19, IWL:0)
	ST	DM(I0+=M0), 0x994		; Im of -0.803208
	ST	DM(I0+=M0), 0x471		; Re of 0.555570	(Coeff.#20, IWL:0)
	ST	DM(I0+=M0), 0x95A		; Im of -0.831470
	ST	DM(I0+=M0), 0x41C		; Re of 0.514103	(Coeff.#21, IWL:0)
	ST	DM(I0+=M0), 0x924		; Im of -0.857729
	ST	DM(I0+=M0), 0x3C5		; Re of 0.471397	(Coeff.#22, IWL:0)
	ST	DM(I0+=M0), 0x8F2		; Im of -0.881921
	ST	DM(I0+=M0), 0x36B		; Re of 0.427555	(Coeff.#23, IWL:0)
	ST	DM(I0+=M0), 0x8C5		; Im of -0.903989
	ST	DM(I0+=M0), 0x30F		; Re of 0.382683	(Coeff.#24, IWL:0)
	ST	DM(I0+=M0), 0x89C		; Im of -0.923880
	ST	DM(I0+=M0), 0x2B1		; Re of 0.336890	(Coeff.#25, IWL:0)
	ST	DM(I0+=M0), 0x878		; Im of -0.941544
	ST	DM(I0+=M0), 0x252		; Re of 0.290285	(Coeff.#26, IWL:0)
	ST	DM(I0+=M0), 0x859		; Im of -0.956940
	ST	DM(I0+=M0), 0x1F1		; Re of 0.242980	(Coeff.#27, IWL:0)
	ST	DM(I0+=M0), 0x83E		; Im of -0.970031
	ST	DM(I0+=M0), 0x18F		; Re of 0.195090	(Coeff.#28, IWL:0)
	ST	DM(I0+=M0), 0x828		; Im of -0.980785
	ST	DM(I0+=M0), 0x12C		; Re of 0.146730	(Coeff.#29, IWL:0)
	ST	DM(I0+=M0), 0x817		; Im of -0.989177
	ST	DM(I0+=M0), 0x0C8		; Re of 0.098017	(Coeff.#30, IWL:0)
	ST	DM(I0+=M0), 0x80A		; Im of -0.995185
	ST	DM(I0+=M0), 0x064		; Re of 0.049068	(Coeff.#31, IWL:0)
	ST	DM(I0+=M0), 0x803		; Im of -0.998795
	ST	DM(I0+=M0), 0x000		; Re of -0.000000	(Coeff.#32, IWL:0)
	ST	DM(I0+=M0), 0x800		; Im of -1.000000
	ST	DM(I0+=M0), 0xF9C		; Re of -0.049068	(Coeff.#33, IWL:0)
	ST	DM(I0+=M0), 0x803		; Im of -0.998795
	ST	DM(I0+=M0), 0xF38		; Re of -0.098017	(Coeff.#34, IWL:0)
	ST	DM(I0+=M0), 0x80A		; Im of -0.995185
	ST	DM(I0+=M0), 0xED4		; Re of -0.146730	(Coeff.#35, IWL:0)
	ST	DM(I0+=M0), 0x817		; Im of -0.989177
	ST	DM(I0+=M0), 0xE71		; Re of -0.195090	(Coeff.#36, IWL:0)
	ST	DM(I0+=M0), 0x828		; Im of -0.980785
	ST	DM(I0+=M0), 0xE0F		; Re of -0.242980	(Coeff.#37, IWL:0)
	ST	DM(I0+=M0), 0x83E		; Im of -0.970031
	ST	DM(I0+=M0), 0xDAE		; Re of -0.290285	(Coeff.#38, IWL:0)
	ST	DM(I0+=M0), 0x859		; Im of -0.956940
	ST	DM(I0+=M0), 0xD4F		; Re of -0.336890	(Coeff.#39, IWL:0)
	ST	DM(I0+=M0), 0x878		; Im of -0.941544
	ST	DM(I0+=M0), 0xCF1		; Re of -0.382683	(Coeff.#40, IWL:0)
	ST	DM(I0+=M0), 0x89C		; Im of -0.923880
	ST	DM(I0+=M0), 0xC95		; Re of -0.427555	(Coeff.#41, IWL:0)
	ST	DM(I0+=M0), 0x8C5		; Im of -0.903989
	ST	DM(I0+=M0), 0xC3B		; Re of -0.471397	(Coeff.#42, IWL:0)
	ST	DM(I0+=M0), 0x8F2		; Im of -0.881921
	ST	DM(I0+=M0), 0xBE4		; Re of -0.514103	(Coeff.#43, IWL:0)
	ST	DM(I0+=M0), 0x924		; Im of -0.857729
	ST	DM(I0+=M0), 0xB8F		; Re of -0.555570	(Coeff.#44, IWL:0)
	ST	DM(I0+=M0), 0x95A		; Im of -0.831470
	ST	DM(I0+=M0), 0xB3D		; Re of -0.595699	(Coeff.#45, IWL:0)
	ST	DM(I0+=M0), 0x994		; Im of -0.803208
	ST	DM(I0+=M0), 0xAED		; Re of -0.634393	(Coeff.#46, IWL:0)
	ST	DM(I0+=M0), 0x9D1		; Im of -0.773010
	ST	DM(I0+=M0), 0xAA1		; Re of -0.671559	(Coeff.#47, IWL:0)
	ST	DM(I0+=M0), 0xA13		; Im of -0.740951
	ST	DM(I0+=M0), 0xA58		; Re of -0.707107	(Coeff.#48, IWL:0)
	ST	DM(I0+=M0), 0xA58		; Im of -0.707107
	ST	DM(I0+=M0), 0xA13		; Re of -0.740951	(Coeff.#49, IWL:0)
	ST	DM(I0+=M0), 0xAA1		; Im of -0.671559
	ST	DM(I0+=M0), 0x9D1		; Re of -0.773010	(Coeff.#50, IWL:0)
	ST	DM(I0+=M0), 0xAED		; Im of -0.634393
	ST	DM(I0+=M0), 0x994		; Re of -0.803208	(Coeff.#51, IWL:0)
	ST	DM(I0+=M0), 0xB3D		; Im of -0.595699
	ST	DM(I0+=M0), 0x95A		; Re of -0.831470	(Coeff.#52, IWL:0)
	ST	DM(I0+=M0), 0xB8F		; Im of -0.555570
	ST	DM(I0+=M0), 0x924		; Re of -0.857729	(Coeff.#53, IWL:0)
	ST	DM(I0+=M0), 0xBE4		; Im of -0.514103
	ST	DM(I0+=M0), 0x8F2		; Re of -0.881921	(Coeff.#54, IWL:0)
	ST	DM(I0+=M0), 0xC3B		; Im of -0.471397
	ST	DM(I0+=M0), 0x8C5		; Re of -0.903989	(Coeff.#55, IWL:0)
	ST	DM(I0+=M0), 0xC95		; Im of -0.427555
	ST	DM(I0+=M0), 0x89C		; Re of -0.923880	(Coeff.#56, IWL:0)
	ST	DM(I0+=M0), 0xCF1		; Im of -0.382683
	ST	DM(I0+=M0), 0x878		; Re of -0.941544	(Coeff.#57, IWL:0)
	ST	DM(I0+=M0), 0xD4F		; Im of -0.336890
	ST	DM(I0+=M0), 0x859		; Re of -0.956940	(Coeff.#58, IWL:0)
	ST	DM(I0+=M0), 0xDAE		; Im of -0.290285
	ST	DM(I0+=M0), 0x83E		; Re of -0.970031	(Coeff.#59, IWL:0)
	ST	DM(I0+=M0), 0xE0F		; Im of -0.242980
	ST	DM(I0+=M0), 0x828		; Re of -0.980785	(Coeff.#60, IWL:0)
	ST	DM(I0+=M0), 0xE71		; Im of -0.195090
	ST	DM(I0+=M0), 0x817		; Re of -0.989177	(Coeff.#61, IWL:0)
	ST	DM(I0+=M0), 0xED4		; Im of -0.146730
	ST	DM(I0+=M0), 0x80A		; Re of -0.995185	(Coeff.#62, IWL:0)
	ST	DM(I0+=M0), 0xF38		; Im of -0.098017
	ST	DM(I0+=M0), 0x803		; Re of -0.998795	(Coeff.#63, IWL:0)
	ST	DM(I0+=M0), 0xF9C		; Im of -0.049068
	ST	DM(I0+=M0), 0x800		; Re of -1.000000	(Coeff.#64, IWL:0)
	ST	DM(I0+=M0), 0x000		; Im of 0.000000
	ST	DM(I0+=M0), 0x803		; Re of -0.998795	(Coeff.#65, IWL:0)
	ST	DM(I0+=M0), 0x064		; Im of 0.049068
	ST	DM(I0+=M0), 0x80A		; Re of -0.995185	(Coeff.#66, IWL:0)
	ST	DM(I0+=M0), 0x0C8		; Im of 0.098017
	ST	DM(I0+=M0), 0x817		; Re of -0.989177	(Coeff.#67, IWL:0)
	ST	DM(I0+=M0), 0x12C		; Im of 0.146730
	ST	DM(I0+=M0), 0x828		; Re of -0.980785	(Coeff.#68, IWL:0)
	ST	DM(I0+=M0), 0x18F		; Im of 0.195090
	ST	DM(I0+=M0), 0x83E		; Re of -0.970031	(Coeff.#69, IWL:0)
	ST	DM(I0+=M0), 0x1F1		; Im of 0.242980
	ST	DM(I0+=M0), 0x859		; Re of -0.956940	(Coeff.#70, IWL:0)
	ST	DM(I0+=M0), 0x252		; Im of 0.290285
	ST	DM(I0+=M0), 0x878		; Re of -0.941544	(Coeff.#71, IWL:0)
	ST	DM(I0+=M0), 0x2B1		; Im of 0.336890
	ST	DM(I0+=M0), 0x89C		; Re of -0.923880	(Coeff.#72, IWL:0)
	ST	DM(I0+=M0), 0x30F		; Im of 0.382683
	ST	DM(I0+=M0), 0x8C5		; Re of -0.903989	(Coeff.#73, IWL:0)
	ST	DM(I0+=M0), 0x36B		; Im of 0.427555
	ST	DM(I0+=M0), 0x8F2		; Re of -0.881921	(Coeff.#74, IWL:0)
	ST	DM(I0+=M0), 0x3C5		; Im of 0.471397
	ST	DM(I0+=M0), 0x924		; Re of -0.857729	(Coeff.#75, IWL:0)
	ST	DM(I0+=M0), 0x41C		; Im of 0.514103
	ST	DM(I0+=M0), 0x95A		; Re of -0.831470	(Coeff.#76, IWL:0)
	ST	DM(I0+=M0), 0x471		; Im of 0.555570
	ST	DM(I0+=M0), 0x994		; Re of -0.803208	(Coeff.#77, IWL:0)
	ST	DM(I0+=M0), 0x4C3		; Im of 0.595699
	ST	DM(I0+=M0), 0x9D1		; Re of -0.773010	(Coeff.#78, IWL:0)
	ST	DM(I0+=M0), 0x513		; Im of 0.634393
	ST	DM(I0+=M0), 0xA13		; Re of -0.740951	(Coeff.#79, IWL:0)
	ST	DM(I0+=M0), 0x55F		; Im of 0.671559
	ST	DM(I0+=M0), 0xA58		; Re of -0.707107	(Coeff.#80, IWL:0)
	ST	DM(I0+=M0), 0x5A8		; Im of 0.707107
	ST	DM(I0+=M0), 0xAA1		; Re of -0.671559	(Coeff.#81, IWL:0)
	ST	DM(I0+=M0), 0x5ED		; Im of 0.740951
	ST	DM(I0+=M0), 0xAED		; Re of -0.634393	(Coeff.#82, IWL:0)
	ST	DM(I0+=M0), 0x62F		; Im of 0.773010
	ST	DM(I0+=M0), 0xB3D		; Re of -0.595699	(Coeff.#83, IWL:0)
	ST	DM(I0+=M0), 0x66C		; Im of 0.803208
	ST	DM(I0+=M0), 0xB8F		; Re of -0.555570	(Coeff.#84, IWL:0)
	ST	DM(I0+=M0), 0x6A6		; Im of 0.831470
	ST	DM(I0+=M0), 0xBE4		; Re of -0.514103	(Coeff.#85, IWL:0)
	ST	DM(I0+=M0), 0x6DC		; Im of 0.857729
	ST	DM(I0+=M0), 0xC3B		; Re of -0.471397	(Coeff.#86, IWL:0)
	ST	DM(I0+=M0), 0x70E		; Im of 0.881921
	ST	DM(I0+=M0), 0xC95		; Re of -0.427555	(Coeff.#87, IWL:0)
	ST	DM(I0+=M0), 0x73B		; Im of 0.903989
	ST	DM(I0+=M0), 0xCF1		; Re of -0.382683	(Coeff.#88, IWL:0)
	ST	DM(I0+=M0), 0x764		; Im of 0.923880
	ST	DM(I0+=M0), 0xD4F		; Re of -0.336890	(Coeff.#89, IWL:0)
	ST	DM(I0+=M0), 0x788		; Im of 0.941544
	ST	DM(I0+=M0), 0xDAE		; Re of -0.290285	(Coeff.#90, IWL:0)
	ST	DM(I0+=M0), 0x7A7		; Im of 0.956940
	ST	DM(I0+=M0), 0xE0F		; Re of -0.242980	(Coeff.#91, IWL:0)
	ST	DM(I0+=M0), 0x7C2		; Im of 0.970031
	ST	DM(I0+=M0), 0xE71		; Re of -0.195090	(Coeff.#92, IWL:0)
	ST	DM(I0+=M0), 0x7D8		; Im of 0.980785
	ST	DM(I0+=M0), 0xED4		; Re of -0.146730	(Coeff.#93, IWL:0)
	ST	DM(I0+=M0), 0x7E9		; Im of 0.989177
	ST	DM(I0+=M0), 0xF38		; Re of -0.098017	(Coeff.#94, IWL:0)
	ST	DM(I0+=M0), 0x7F6		; Im of 0.995185
	ST	DM(I0+=M0), 0xF9C		; Re of -0.049068	(Coeff.#95, IWL:0)
	ST	DM(I0+=M0), 0x7FD		; Im of 0.998795
	ST	DM(I0+=M0), 0x000		; Re of 0.000000	(Coeff.#96, IWL:0)
	ST	DM(I0+=M0), 0x7FF		; Im of 1.000000
	ST	DM(I0+=M0), 0x064		; Re of 0.049068	(Coeff.#97, IWL:0)
	ST	DM(I0+=M0), 0x7FD		; Im of 0.998795
	ST	DM(I0+=M0), 0x0C8		; Re of 0.098017	(Coeff.#98, IWL:0)
	ST	DM(I0+=M0), 0x7F6		; Im of 0.995185
	ST	DM(I0+=M0), 0x12C		; Re of 0.146730	(Coeff.#99, IWL:0)
	ST	DM(I0+=M0), 0x7E9		; Im of 0.989177
	ST	DM(I0+=M0), 0x18F		; Re of 0.195090	(Coeff.#100, IWL:0)
	ST	DM(I0+=M0), 0x7D8		; Im of 0.980785
	ST	DM(I0+=M0), 0x1F1		; Re of 0.242980	(Coeff.#101, IWL:0)
	ST	DM(I0+=M0), 0x7C2		; Im of 0.970031
	ST	DM(I0+=M0), 0x252		; Re of 0.290285	(Coeff.#102, IWL:0)
	ST	DM(I0+=M0), 0x7A7		; Im of 0.956940
	ST	DM(I0+=M0), 0x2B1		; Re of 0.336890	(Coeff.#103, IWL:0)
	ST	DM(I0+=M0), 0x788		; Im of 0.941544
	ST	DM(I0+=M0), 0x30F		; Re of 0.382683	(Coeff.#104, IWL:0)
	ST	DM(I0+=M0), 0x764		; Im of 0.923880
	ST	DM(I0+=M0), 0x36B		; Re of 0.427555	(Coeff.#105, IWL:0)
	ST	DM(I0+=M0), 0x73B		; Im of 0.903989
	ST	DM(I0+=M0), 0x3C5		; Re of 0.471397	(Coeff.#106, IWL:0)
	ST	DM(I0+=M0), 0x70E		; Im of 0.881921
	ST	DM(I0+=M0), 0x41C		; Re of 0.514103	(Coeff.#107, IWL:0)
	ST	DM(I0+=M0), 0x6DC		; Im of 0.857729
	ST	DM(I0+=M0), 0x471		; Re of 0.555570	(Coeff.#108, IWL:0)
	ST	DM(I0+=M0), 0x6A6		; Im of 0.831470
	ST	DM(I0+=M0), 0x4C3		; Re of 0.595699	(Coeff.#109, IWL:0)
	ST	DM(I0+=M0), 0x66C		; Im of 0.803208
	ST	DM(I0+=M0), 0x513		; Re of 0.634393	(Coeff.#110, IWL:0)
	ST	DM(I0+=M0), 0x62F		; Im of 0.773010
	ST	DM(I0+=M0), 0x55F		; Re of 0.671559	(Coeff.#111, IWL:0)
	ST	DM(I0+=M0), 0x5ED		; Im of 0.740951
	ST	DM(I0+=M0), 0x5A8		; Re of 0.707107	(Coeff.#112, IWL:0)
	ST	DM(I0+=M0), 0x5A8		; Im of 0.707107
	ST	DM(I0+=M0), 0x5ED		; Re of 0.740951	(Coeff.#113, IWL:0)
	ST	DM(I0+=M0), 0x55F		; Im of 0.671559
	ST	DM(I0+=M0), 0x62F		; Re of 0.773010	(Coeff.#114, IWL:0)
	ST	DM(I0+=M0), 0x513		; Im of 0.634393
	ST	DM(I0+=M0), 0x66C		; Re of 0.803208	(Coeff.#115, IWL:0)
	ST	DM(I0+=M0), 0x4C3		; Im of 0.595699
	ST	DM(I0+=M0), 0x6A6		; Re of 0.831470	(Coeff.#116, IWL:0)
	ST	DM(I0+=M0), 0x471		; Im of 0.555570
	ST	DM(I0+=M0), 0x6DC		; Re of 0.857729	(Coeff.#117, IWL:0)
	ST	DM(I0+=M0), 0x41C		; Im of 0.514103
	ST	DM(I0+=M0), 0x70E		; Re of 0.881921	(Coeff.#118, IWL:0)
	ST	DM(I0+=M0), 0x3C5		; Im of 0.471397
	ST	DM(I0+=M0), 0x73B		; Re of 0.903989	(Coeff.#119, IWL:0)
	ST	DM(I0+=M0), 0x36B		; Im of 0.427555
	ST	DM(I0+=M0), 0x764		; Re of 0.923880	(Coeff.#120, IWL:0)
	ST	DM(I0+=M0), 0x30F		; Im of 0.382683
	ST	DM(I0+=M0), 0x788		; Re of 0.941544	(Coeff.#121, IWL:0)
	ST	DM(I0+=M0), 0x2B1		; Im of 0.336890
	ST	DM(I0+=M0), 0x7A7		; Re of 0.956940	(Coeff.#122, IWL:0)
	ST	DM(I0+=M0), 0x252		; Im of 0.290285
	ST	DM(I0+=M0), 0x7C2		; Re of 0.970031	(Coeff.#123, IWL:0)
	ST	DM(I0+=M0), 0x1F1		; Im of 0.242980
	ST	DM(I0+=M0), 0x7D8		; Re of 0.980785	(Coeff.#124, IWL:0)
	ST	DM(I0+=M0), 0x18F		; Im of 0.195090
	ST	DM(I0+=M0), 0x7E9		; Re of 0.989177	(Coeff.#125, IWL:0)
	ST	DM(I0+=M0), 0x12C		; Im of 0.146730
	ST	DM(I0+=M0), 0x7F6		; Re of 0.995185	(Coeff.#126, IWL:0)
	ST	DM(I0+=M0), 0x0C8		; Im of 0.098017
	ST	DM(I0+=M0), 0x7FD		; Re of 0.998795	(Coeff.#127, IWL:0)
	ST	DM(I0+=M0), 0x064		; Im of 0.049068
;---------------------------------------------------------------------------
; Function y = fft128(x)
;---------------------------------------------------------------------------
; Function Input: x (IWL = 0)
;---------------------------------------------------------------------------
; Stage 1: N = 2, r = 0, IWL = 1, W(r)_2 = W(64r)_128
; Stage Input: x (IWL = 0), Stage Output: s1 (IWL = 1);
;---------------------------------------------------------------------------
; if size(x) ~= [128 1]
;     error('fft size is not [128 1]')
; else
; 	for ii=0:63
; 		s1(ii+1:64:128,1) = fft2(x(ii+1:64:128,1));
;		;; s1[ii+ 0] = x[ii+ 0] + x[ii+64]
;		;; s1[ii+64] = x[ii+ 0] - x[ii+64]
; 	end
;-------------------------------------------------------------------------------
;		LD	CNTR, 64
;		LD	I0, 0x000				; I0 = &x0[0]
;		LD	M0, 2			
;		LD	I2, 0x080				; I2 = &x0[64]
;		LD	M2, 2
;		LD	I4, 0x100				; I4 = &s1[0]
;		LD	M4, 2	
;		LD	I6, 0x180				; I6 = &s1[64]
;		LD	M6, 2
;
;		DO	ll1	UNTIL	CE
;; 10 instructions in this innermost loop
;		CLRACC.C	ACC0				; ACC0 <= 0					
;		CLRACC.C	ACC2				; ACC2 <= 0					
;		LD.C	ACC0.M, DM(I0+=M0) 		; ACC0.M = *I0++;	(IWL:0)
;		LD.C	ACC2.M, DM(I2+=M2) 		; ACC2.M = *I2++;	(IWL:0)
;		ASHIFT.C	ACC0, ACC0, -1 (NORND) 		; ACC0 = (ACC0>>1); (IWL:1)
;		ASHIFT.C	ACC2, ACC2, -1 (NORND)		; ACC2 = (ACC2>>1); (IWL:1)
;		ADD.C	ACC4, ACC0, ACC2		; ACC4 = ACC0 + ACC2;	(IWL:1)
;		SUB.C	ACC6, ACC0, ACC2		; ACC6 = ACC0 - ACC2;	(IWL:1)
;		ST.C	DM(I4+=M4), ACC4.M		; *I4++ = ACC4.M; (IWL:1)
;ll1:	ST.C	DM(I6+=M6), ACC6.M		; *I6++ = ACC6.M; (IWL:1)
;-------------------------------------------------------------------------------
		LD	CNTR, 64
		LD	I0, 0x000					; I0 = &x0[0]
		LD	M0, 2			
		LD	I4, 0x080					; I4 = &x0[64]
		LD	M4, 2
		LD	I2, 0x100					; I2 = &s1[0]
		LD	M2, 2	
		LD	I6, 0x180					; I6 = &s1[64]
		LD	M6, 2
; begin: inner loop
		DO	ll1	UNTIL	CE
; 7 instructions in this loop
		LD.C	R0, DM(I0+=M0) 	||	LD.C	R4, DM(I4+=M4) 			; R0 = *I0++ (IWL:0) || R4 = *I4++ (IWL:0)
		ASHIFT.C	ACC0, R0, -1 (HI) 	; ACC0 = (R0>>1); (IWL:1)
		ASHIFT.C	ACC2, R4, -1 (HI) || CP.C	R0, ACC0.M			; ACC2 = (R4>>1) (IWL:1) || R0 = ACC0.M (IWL:1)
		CP.C	R4, ACC2.M				; R4 = ACC2.M;	(IWL:1)
		ADD.C	R2, R0, R4				; R2 = R0 + R4;	(IWL:1)
		SUB.C	R6, R0, R4	|| ST.C	DM(I2+=M2), R2					; R6 = R0 - R4	(IWL:1) || *I2++ = R2 (IWL:1)
ll1:	ST.C	DM(I6+=M6), R6			; *I6++ = R6; (IWL:1)
; end: inner loop
;---------------------------------------------------------------------------
; Stage 2: N = 4, r = 0 ~ 1, IWL = 2, W(r)_4 = W(32r)_128
; Stage Input: s1 (IWL = 1), Stage Output: s2 (IWL = 2);
;---------------------------------------------------------------------------
; for jj=0:31
; 	for ii=0:1
; 		s2(jj+ii*32+1:64:128,1) = fft2(exp(-j*pi*(0:1)'*ii/2).*s1(jj+ii*64+1:32:jj+ii*64+64,1));
; 		;; s2[jj+ii*32+ 0] = s1[jj+ii*64+0] + W(ii*32)_128 * s1[jj+ii*64+32];
; 		;; s2[jj+ii*32+64] = s1[jj+ii*64+0] - W(ii*32)_128 * s1[jj+ii*64+32];
; 	end
; end
;-------------------------------------------------------------------------------
;		LD	CNTR, 32
;		LD	I1, 0x100				; I1 = &s1[0]
;		CP	R22, I1					; backup I1 to R22
;		LD	I4, 0x200				; I4 = &s2[0];
;		CP	R20, I4					; backup I4 to R20
;		LD	M1, 64					; for s1[x+32] addressing with s1[x] address
;		LD	M5, 128					; for s2[x+64] addressing with s2[x] address
;		DO ll20 UNTIL CE
;		LD	CNTR, 2
;		CP	I0, R22					; I0 = &s1[jj]
;		LD	M0, 128					; M0 = 64*2 (complex pair)
;		LD	I7, 0x800				; I7 = &W[0] 
;		LD	M7, 64					; 32*2 (complex pair)
;		CP	I4, R20					; I4 = &s2[jj]
;		LD	M4, 64					; 32*2 (complex pair)
;		DO	ll2	UNTIL CE
;; 13 instructions in this innermost loop
;		LD.C	R2, DM(I0+M1)		; R2  <= s1[jj+ii*64+32] = *(I0+32);			(IWL:1)
;		CLRACC.C	ACC0			; ACC0 <= 0					
;		LD.C	ACC0.M, DM(I0+=M0)	; ACC0.M  <= s1[jj+ii*64] = *I0, I0 += 64;		(IWL:1)
;		CP.C	ACC2, ACC0			; ACC2 <= s1[jj+ii*64] = ACC0;					(IWL:1)
;		LD.C	R8, DM(I7+=M7);		; R8  <= W(ii*32)_128, I7 += 32;				(IWL:0)
;		ASHIFT.C	ACC6, R8, -1 (HI)	; ACC6.M <= (R8>>1)							(IWL:1)
;		CP.C	R8, ACC6.M			; R8 <= ACC6.M									(IWL:1)
;		ASHIFT.C	ACC0, ACC0, -1 (NORND)	; ACC0 <= (ACC0>>1);							(IWL:2)
;		ASHIFT.C	ACC2, ACC2, -1 (NORND)	; ACC2 <= (ACC2>>1);							(IWL:2)
;		MAC.C	ACC0, R2, R8 (SS)	; ACC0 <= ACC0 + (R2 * R8);						(IWL:1+1): Fractional Mode
;		MAS.C	ACC2, R2, R8 (SS)	; ACC2 <= ACC2 - (R2 * R8);						(IWL:1+1): Fractional Mode
;		ST.C	DM(I4+M5), ACC2.M	; s2[jj+ii*32+64] = *(I4+64) <= ACC2.M;			(IWL:2)
;ll2:	ST.C	DM(I4+=M4), ACC0.M	; s2[jj+ii*32   ] = *I4 <= ACC0.M, I4 += 32;	(IWL:2)
;		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s1[0] + jj, jj++;
;ll20:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s2[0] + jj, jj++;
;-------------------------------------------------------------------------------
		LD	CNTR, 32
		LD	I1, 0x100				; I1 = &s1[0]
		CP.C	R22, I1				; backup I1 to R22
		LD	I4, 0x200				; I4 = &s2[0];
		CP.C	R20, I4				; backup I4 to R20
		LD	M1, 64					; for s1[x+32] addressing with s1[x] address
		LD	M5, 64					; for s2[x+64] addressing with s2[x] address: modified to (128-M4)
; begin: outer loop
		DO ll20 UNTIL CE
		LD	CNTR, 2
		CP.C	I0, R22				; I0 = &s1[jj]
		LD	M0, 64					; M0 = 64*2 - M1: modified
		LD	I7, 0x800				; I7 = &W[0] 
		LD	M7, 64					; 32*2 (complex pair)
		CP.C	I4, R20				; I4 = &s2[jj]
		LD	M4, 64					; 32*2 (complex pair)
; begin: inner loop
		DO	ll2	UNTIL CE
; 7 instructions in this loop
		LD.C	R0, DM(I0+=M0) || LD.C	R6, DM(I7+=M7)			; R0  <= s1[jj+ii*64] = *I0, I0 += 64 (IWL:1) || R6  <= W(ii*32)_128, I7 += 32 (IWL:0) 
		ASHIFT.C	ACC2, R6, -1 (HI) || CP.C	R4, R0			; ACC2.M <= (R6>>1)	(IWL:1) || R4 <= s1[jj+ii*64] = R0 (IWL:1)
		ASHIFT.C	ACC0, R0, -1 (HI) || CP.C	R6, ACC2.M		; ACC0 <= (R0>>1) (IWL:2) || R6 <= ACC2.M (IWL:1)
		ASHIFT.C	ACC2, R4, -1 (HI) || LD.C	R2, DM(I0+=M1)	; ACC2 <= (R4>>1) (IWL:2) || R2  <= s1[jj+ii*64+32] = *(I0+32) (IWL:1)
		MAC.C	ACC0, R2, R6 (SS)								; ACC0 <= ACC0 + (R2 * R6) (IWL:1+1): Fractional Mode
		MAS.C	ACC2, R2, R6 (SS) || ST.C	DM(I4+=M4), ACC0.M	; ACC2 <= ACC2 - (R2 * R6) (IWL:1+1) || s2[jj+ii*32   ] = *I4 <= ACC0.M, I4 += 32 (IWL:2)
ll2:	ST.C	DM(I4+M5), ACC2.M								; s2[jj+ii*32+64] = *(I4+64) <= ACC2.M (IWL:2)
; end: inner loop
		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s1[0] + jj, jj++;
ll20:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s2[0] + jj, jj++;
; end: outer loop
;
;---------------------------------------------------------------------------
; Stage 3: N = 8, r = 0 ~ 3, IWL = 3, W(r)_8 = W(16r)_128
;---------------------------------------------------------------------------
; for jj=0:15
; 	for ii=0:3
; 		s3(jj+ii*16+1:64:128,1) = fft2(exp(-j*pi*(0:1)'*ii/4).*s2(jj+ii*32+1:16:jj+ii*32+32,1));
; 		;; s3[jj+ii*16+ 0] = s2[jj+ii*32+0] + W(16r)_128 * s2[jj+ii*32+16];
; 		;; s3[jj+ii*16+64] = s2[jj+ii*32+0] - W(16r)_128 * s2[jj+ii*32+16];
; 	end
; end
;-------------------------------------------------------------------------------
;		LD	CNTR, 16
;		LD	I1, 0x200				; I1 = &s2[0]
;		CP	R22, I1					; backup I1 to R22
;		LD	I4, 0x300				; I4 = &s3[0];
;		CP	R20, I4					; backup I4 to R20
;		LD	M1, 32					; for s2[x+16] addressing with s2[x] address
;;		LD	M5, 128					; for s3[x+64] addressing with s3[x] address
;		DO ll30 UNTIL CE
;		LD	CNTR, 4
;		CP	I0, R22					; I0 = &s2[jj]
;		LD	M0, 64					; M0 = 32*2 (complex pair)
;		LD	I7, 0x800				; I7 = &W[0] 
;		LD	M7, 32					; 16*2 (complex pair)
;		CP	I4, R20					; I4 = &s3[jj]
;		LD	M4, 32					; 16*2 (complex pair)
;		DO	ll3	UNTIL CE
;; 13 instructions in this innermost loop
;		LD.C	R2, DM(I0+M1)		; R2  <= s2[jj+ii*32+16] = *(I0+16);			(IWL:2)
;		CLRACC.C	ACC0			; ACC0 <= 0					
;		LD.C	ACC0.M, DM(I0+=M0)	; ACC0.M  <= s2[jj+ii*32] = *I0, I0 += 32;		(IWL:2)
;		CP.C	ACC2, ACC0			; ACC2 <= s2[jj+ii*32] = ACC0;					(IWL:2)
;		LD.C	R8, DM(I7+=M7);		; R8  <= W(ii*16)_128, I7 += 16;				(IWL:0)
;		ASHIFT.C	ACC6, R8, -1 (HI)	; ACC6.M <= (R8>>1)							(IWL:1)
;		CP.C	R8, ACC6.M			; R8 <= ACC6.M									(IWL:1)
;		ASHIFT.C	ACC0, ACC0, -1 (NORND)	; ACC0 <= (ACC0>>1);							(IWL:3)
;		ASHIFT.C	ACC2, ACC2, -1 (NORND)	; ACC2 <= (ACC2>>1);							(IWL:3)
;		MAC.C	ACC0, R2, R8 (SS)	; ACC0 <= ACC0 + (R2 * R8);						(IWL:2+1): Fractional Mode
;		MAS.C	ACC2, R2, R8 (SS)	; ACC2 <= ACC2 - (R2 * R8);						(IWL:2+1): Fractional Mode
;		ST.C	DM(I4+M5), ACC2.M	; s3[jj+ii*16+64] = *(I4+64) <= ACC2.M;			(IWL:3)
;ll3:	ST.C	DM(I4+=M4), ACC0.M	; s3[jj+ii*16   ] = *I4 <= ACC0.M, I4 += 16;	(IWL:3)
;		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s2[0] + jj, jj++;
;ll30:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s3[0] + jj, jj++;
;-------------------------------------------------------------------------------
		LD	CNTR, 16
		LD	I1, 0x200				; I1 = &s2[0]
		CP.C	R22, I1				; backup I1 to R22
		LD	I4, 0x300				; I4 = &s3[0];
		CP.C	R20, I4				; backup I4 to R20
		LD	M1, 32					; for s2[x+16] addressing with s2[x] address
		LD	M5, 96					; for s3[x+64] addressing with s3[x] address: modified to (128-M4)
; begin: outer loop
		DO ll30 UNTIL CE
		LD	CNTR, 4
		CP.C	I0, R22				; I0 = &s2[jj]
		LD	M0, 32					; M0 = 32*2 - M1: modified
		LD	I7, 0x800				; I7 = &W[0] 
		LD	M7, 32					; 16*2 (complex pair)
		CP.C	I4, R20				; I4 = &s3[jj]
		LD	M4, 32					; 16*2 (complex pair)
; begin: inner loop
		DO	ll3	UNTIL CE
; 7 instructions in this loop
		LD.C	R0, DM(I0+=M0) || LD.C	R6, DM(I7+=M7)			; R0  <= s2[jj+ii*32] = *I0, I0 += 32 (IWL:2) || R6  <= W(ii*16)_128, I7 += 16 (IWL:0) 
		ASHIFT.C	ACC2, R6, -1 (HI) || CP.C	R4, R0			; ACC2.M <= (R6>>1)	(IWL:1) || R4 <= s2[jj+ii*32] = R0 (IWL:2)
		ASHIFT.C	ACC0, R0, -1 (HI) || CP.C	R6, ACC2.M		; ACC0 <= (R0>>1) (IWL:3) || R6 <= ACC2.M (IWL:1)
		ASHIFT.C	ACC2, R4, -1 (HI) || LD.C	R2, DM(I0+=M1)	; ACC2 <= (R4>>1) (IWL:3) || R2  <= s2[jj+ii*32+16] = *(I0+16) (IWL:2)
		MAC.C	ACC0, R2, R6 (SS)								; ACC0 <= ACC0 + (R2 * R6) (IWL:2+1): Fractional Mode
		MAS.C	ACC2, R2, R6 (SS) || ST.C	DM(I4+=M4), ACC0.M	; ACC2 <= ACC2 - (R2 * R6) (IWL:2+1) || s3[jj+ii*16   ] = *I4 <= ACC0.M, I4 += 16 (IWL:3)
ll3:	ST.C	DM(I4+M5), ACC2.M								; s3[jj+ii*16+64] = *(I4+64) <= ACC2.M (IWL:3)
; end: inner loop
		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s2[0] + jj, jj++;
ll30:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s3[0] + jj, jj++;
; end: outer loop
;
;---------------------------------------------------------------------------
; Stage 4: N = 16, r = 0 ~ 7, IWL = 4, W(r)_16 = W(8r)_128
;---------------------------------------------------------------------------
; for jj=0:7
; 	for ii=0:7
; 		s4(jj+ii*8+1:64:128,1) = fft2(exp(-j*pi*(0:1)'*ii/8).*s3(jj+ii*16+1:8:jj+ii*16+16,1));
; 		;; s4[jj+ii*8+ 0] = s3[jj+ii*16+0] + W(8r)_128 * s3[jj+ii*16+8];
; 		;; s4[jj+ii*8+64] = s3[jj+ii*16+0] - W(8r)_128 * s3[jj+ii*16+8];
; 	end
; end
;-------------------------------------------------------------------------------
;		LD	CNTR, 8
;		LD	I1, 0x300				; I1 = &s3[0]
;		CP	R22, I1					; backup I1 to R22
;		LD	I4, 0x400				; I4 = &s4[0];
;		CP	R20, I4					; backup I4 to R20
;		LD	M1, 16					; for s3[x+ 8] addressing with s3[x] address
;;		LD	M5, 128					; for s4[x+64] addressing with s4[x] address
;		DO ll40 UNTIL CE
;		LD	CNTR, 8
;		CP	I0, R22					; I0 = &s3[jj]
;		LD	M0, 32					; M0 = 16*2 (complex pair)
;		LD	I7, 0x800				; I7 = &W[0] 
;		LD	M7, 16					; 8*2 (complex pair)
;		CP	I4, R20					; I4 = &s4[jj]
;		LD	M4, 16					; 8*2 (complex pair)
;		DO	ll4	UNTIL CE
;; 13 instructions in this innermost loop
;		LD.C	R2, DM(I0+M1)		; R2  <= s3[jj+ii*16+8] = *(I0+8);			(IWL:3)
;		CLRACC.C	ACC0			; ACC0 <= 0					
;		LD.C	ACC0.M, DM(I0+=M0)	; ACC0.M  <= s3[jj+ii*16] = *I0, I0 += 16;	(IWL:3)
;		CP.C	ACC2, ACC0			; ACC2 <= s3[jj+ii*16] = ACC0;				(IWL:3)
;		LD.C	R8, DM(I7+=M7);		; R8  <= W(ii*8)_128, I7 += 8;				(IWL:0)
;		ASHIFT.C	ACC6, R8, -1 (HI)	; ACC6.M <= (R8>>1)						(IWL:1)
;		CP.C	R8, ACC6.M			; R8 <= ACC6.M								(IWL:1)
;		ASHIFT.C	ACC0, ACC0, -1 (NORND)	; ACC0 <= (ACC0>>1);						(IWL:4)
;		ASHIFT.C	ACC2, ACC2, -1 (NORND)	; ACC2 <= (ACC2>>1);						(IWL:4)
;		MAC.C	ACC0, R2, R8 (SS)	; ACC0 <= ACC0 + (R2 * R8);					(IWL:3+1): Fractional Mode
;		MAS.C	ACC2, R2, R8 (SS)	; ACC2 <= ACC2 - (R2 * R8);					(IWL:3+1): Fractional Mode
;		ST.C	DM(I4+M5), ACC2.M	; s4[jj+ii*8+64] = *(I4+64) <= ACC2.M;		(IWL:4)
;ll4:	ST.C	DM(I4+=M4), ACC0.M	; s4[jj+ii*8   ] = *I4 <= ACC0.M, I4 += 8;	(IWL:4)
;		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s3[0] + jj, jj++;
;ll40:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s4[0] + jj, jj++;
;-------------------------------------------------------------------------------
		LD	CNTR, 8
		LD	I1, 0x300				; I1 = &s3[0]
		CP.C	R22, I1				; backup I1 to R22
		LD	I4, 0x400				; I4 = &s4[0];
		CP.C	R20, I4				; backup I4 to R20
		LD	M1, 16					; for s3[x+ 8] addressing with s3[x] address
		LD	M5, 112					; for s4[x+64] addressing with s4[x] address: modified to (128-M4)
; begin: outer loop
		DO ll40 UNTIL CE
		LD	CNTR, 8
		CP.C	I0, R22				; I0 = &s3[jj]
		LD	M0, 16					; M0 = 16*2 - M1: modified
		LD	I7, 0x800				; I7 = &W[0] 
		LD	M7, 16					; 8*2 (complex pair)
		CP.C	I4, R20				; I4 = &s4[jj]
		LD	M4, 16					; 8*2 (complex pair)
; begin: inner loop
		DO	ll4	UNTIL CE
; 7 instructions in this loop
		LD.C	R0, DM(I0+=M0) || LD.C	R6, DM(I7+=M7)			; R0  <= s3[jj+ii*16] = *I0, I0 += 16 (IWL:3) || R6  <= W(ii*8)_128, I7 += 8 (IWL:0) 
		ASHIFT.C	ACC2, R6, -1 (HI) || CP.C	R4, R0			; ACC2.M <= (R6>>1)	(IWL:1) || R4 <= s3[jj+ii*16] = R0 (IWL:3)
		ASHIFT.C	ACC0, R0, -1 (HI) || CP.C	R6, ACC2.M		; ACC0 <= (R0>>1) (IWL:4) || R6 <= ACC2.M (IWL:1)
		ASHIFT.C	ACC2, R4, -1 (HI) || LD.C	R2, DM(I0+=M1)	; ACC2 <= (R4>>1) (IWL:4) || R2  <= s3[jj+ii*16+8] = *(I0+8) (IWL:3)
		MAC.C	ACC0, R2, R6 (SS)								; ACC0 <= ACC0 + (R2 * R6) (IWL:3+1): Fractional Mode
		MAS.C	ACC2, R2, R6 (SS) || ST.C	DM(I4+=M4), ACC0.M	; ACC2 <= ACC2 - (R2 * R6) (IWL:3+1) || s4[jj+ii*8   ] = *I4 <= ACC0.M, I4 += 8 (IWL:4)
ll4:	ST.C	DM(I4+M5), ACC2.M								; s4[jj+ii*8+64] = *(I4+64) <= ACC2.M (IWL:4)
; end: inner loop
		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s3[0] + jj, jj++;
ll40:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s4[0] + jj, jj++;
; end: outer loop
;
;---------------------------------------------------------------------------
; Stage 5: N = 32, r = 0 ~ 15, IWL = 5, W(r)_32 = W(4r)_128
;---------------------------------------------------------------------------
; for jj=0:3
; 	for ii=0:15
; 		s5(jj+ii*4+1:64:128,1) = fft2(exp(-j*pi*(0:1)'*ii/16).*s4(jj+ii*8+1:4:jj+ii*8+8,1));
; 		;; s5[jj+ii*4+ 0] = s4[jj+ii*8+0] + W(4r)_128 * s4[jj+ii*8+4];
; 		;; s5[jj+ii*4+64] = s4[jj+ii*8+0] - W(4r)_128 * s4[jj+ii*8+4];
; 	end
; end
;-------------------------------------------------------------------------------
;		LD	CNTR, 4
;		LD	I1, 0x400				; I1 = &s4[0]
;		CP	R22, I1					; backup I1 to R22
;		LD	I4, 0x500				; I4 = &s5[0];
;		CP	R20, I4					; backup I4 to R20
;		LD	M1, 8					; for s4[x+ 4] addressing with s4[x] address
;;		LD	M5, 128					; for s5[x+64] addressing with s5[x] address
;		DO ll50 UNTIL CE
;		LD	CNTR, 16
;		CP	I0, R22					; I0 = &s4[jj]
;		LD	M0, 16					; M0 = 8*2 (complex pair)
;		LD	I7, 0x800				; I7 = &W[0] 
;		LD	M7, 8					; 4*2 (complex pair)
;		CP	I4, R20					; I4 = &s5[jj]
;		LD	M4, 8					; 4*2 (complex pair)
;		DO	ll5	UNTIL CE
;; 13 instructions in this innermost loop
;		LD.C	R2, DM(I0+M1)		; R2  <= s4[jj+ii*8+4] = *(I0+4);			(IWL:4)
;		CLRACC.C	ACC0			; ACC0 <= 0					
;		LD.C	ACC0.M, DM(I0+=M0)	; ACC0.M  <= s4[jj+ii*8] = *I0, I0 += 8;	(IWL:4)
;		CP.C	ACC2, ACC0			; ACC2 <= s4[jj+ii*8] = ACC0;				(IWL:4)
;		LD.C	R8, DM(I7+=M7);		; R8  <= W(ii*4)_128, I7 += 4;				(IWL:0)
;		ASHIFT.C	ACC6, R8, -1 (HI)	; ACC6.M <= (R8>>1)						(IWL:1)
;		CP.C	R8, ACC6.M			; R8 <= ACC6.M								(IWL:1)
;		ASHIFT.C	ACC0, ACC0, -1 (NORND)	; ACC0 <= (ACC0>>1);						(IWL:5)
;		ASHIFT.C	ACC2, ACC2, -1 (NORND)	; ACC2 <= (ACC2>>1);						(IWL:5)
;		MAC.C	ACC0, R2, R8 (SS)	; ACC0 <= ACC0 + (R2 * R8);					(IWL:4+1): Fractional Mode
;		MAS.C	ACC2, R2, R8 (SS)	; ACC2 <= ACC2 - (R2 * R8);					(IWL:4+1): Fractional Mode
;		ST.C	DM(I4+M5), ACC2.M	; s5[jj+ii*4+64] = *(I4+64) <= ACC2.M;		(IWL:5)
;ll5:	ST.C	DM(I4+=M4), ACC0.M	; s5[jj+ii*4   ] = *I4 <= ACC0.M, I4 += 4;	(IWL:5)
;		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s4[0] + jj, jj++;
;ll50:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s5[0] + jj, jj++;
;-------------------------------------------------------------------------------
		LD	CNTR, 4
		LD	I1, 0x400				; I1 = &s4[0]
		CP.C	R22, I1				; backup I1 to R22
		LD	I4, 0x500				; I4 = &s5[0];
		CP.C	R20, I4				; backup I4 to R20
		LD	M1, 8					; for s4[x+ 4] addressing with s4[x] address
		LD	M5, 120					; for s5[x+64] addressing with s5[x] address: modified to (128-M4)
; begin: outer loop
		DO ll50 UNTIL CE
		LD	CNTR, 16
		CP.C	I0, R22				; I0 = &s4[jj]
		LD	M0, 8					; M0 = 8*2 - M1: modified
		LD	I7, 0x800				; I7 = &W[0] 
		LD	M7, 8					; 4*2 (complex pair)
		CP.C	I4, R20				; I4 = &s5[jj]
		LD	M4, 8					; 4*2 (complex pair)
; begin: inner loop
		DO	ll5	UNTIL CE
; 7 instructions in this loop
		LD.C	R0, DM(I0+=M0) || LD.C	R6, DM(I7+=M7)			; R0  <= s4[jj+ii*8] = *I0, I0 += 8 (IWL:4) || R6  <= W(ii*4)_128, I7 += 4 (IWL:0) 
		ASHIFT.C	ACC2, R6, -1 (HI) || CP.C	R4, R0			; ACC2.M <= (R6>>1)	(IWL:1) || R4 <= s4[jj+ii*8] = R0 (IWL:4)
		ASHIFT.C	ACC0, R0, -1 (HI) || CP.C	R6, ACC2.M		; ACC0 <= (R0>>1) (IWL:5) || R6 <= ACC2.M (IWL:1)
		ASHIFT.C	ACC2, R4, -1 (HI) || LD.C	R2, DM(I0+=M1)	; ACC2 <= (R4>>1) (IWL:5) || R2  <= s4[jj+ii*8+4] = *(I0+4) (IWL:4)
		MAC.C	ACC0, R2, R6 (SS)								; ACC0 <= ACC0 + (R2 * R6) (IWL:4+1): Fractional Mode
		MAS.C	ACC2, R2, R6 (SS) || ST.C	DM(I4+=M4), ACC0.M	; ACC2 <= ACC2 - (R2 * R6) (IWL:4+1) || s5[jj+ii*4   ] = *I4 <= ACC0.M, I4 += 4 (IWL:5)
ll5:	ST.C	DM(I4+M5), ACC2.M								; s5[jj+ii*4+64] = *(I4+64) <= ACC2.M (IWL:5)
; end: inner loop
		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s4[0] + jj, jj++;
ll50:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s5[0] + jj, jj++;
; end: outer loop
;---------------------------------------------------------------------------
; Stage 6: N = 64, r = 0 ~ 31, IWL = 6, W(r)_64 = W(2r)_128
;---------------------------------------------------------------------------
; for jj=0:1
;   for ii=0:31
;       s6(jj+ii*2+1:64:128,1) = fft2(exp(-j*pi*(0:1)'*ii/32).*s5(jj+ii*4+1:2:jj+ii*4+4,1));
; 		;; s6[jj+ii*2+ 0] = s5[jj+ii*4+0] + W(2r)_128 * s5[jj+ii*4+2];
; 		;; s6[jj+ii*2+64] = s5[jj+ii*4+0] - W(2r)_128 * s5[jj+ii*4+2];
;   end
; end
;-------------------------------------------------------------------------------
;		LD	CNTR, 2
;		LD	I1, 0x500				; I1 = &s5[0]
;		CP	R22, I1					; backup I1 to R22
;		LD	I4, 0x600				; I4 = &s6[0];
;		CP	R20, I4					; backup I4 to R20
;		LD	M1, 4					; for s5[x+ 2] addressing with s5[x] address
;;		LD	M5, 128					; for s6[x+64] addressing with s6[x] address
;		DO ll60 UNTIL CE
;		LD	CNTR, 32
;		CP	I0, R22					; I0 = &s5[jj]
;		LD	M0, 8					; M0 = 4*2 (complex pair)
;		LD	I7, 0x800				; I7 = &W[0] 
;		LD	M7, 4					; 2*2 (complex pair)
;		CP	I4, R20					; I4 = &s6[jj]
;		LD	M4, 4					; 2*2 (complex pair)
;		DO	ll6	UNTIL CE
;; 13 instructions in this innermost loop
;		LD.C	R2, DM(I0+M1)		; R2  <= s5[jj+ii*4+2] = *(I0+2);			(IWL:5)
;		CLRACC.C	ACC0			; ACC0 <= 0					
;		LD.C	ACC0.M, DM(I0+=M0)	; ACC0.M  <= s5[jj+ii*4] = *I0, I0 += 4;	(IWL:5)
;		CP.C	ACC2, ACC0			; ACC2 <= s5[jj+ii*4] = ACC0;				(IWL:5)
;		LD.C	R8, DM(I7+=M7);		; R8  <= W(ii*2)_128, I7 += 2;				(IWL:0)
;		ASHIFT.C	ACC6, R8, -1 (HI)	; ACC6.M <= (R8>>1)						(IWL:1)
;		CP.C	R8, ACC6.M			; R8 <= ACC6.M								(IWL:1)
;		ASHIFT.C	ACC0, ACC0, -1 (NORND)	; ACC0 <= (ACC0>>1);						(IWL:6)
;		ASHIFT.C	ACC2, ACC2, -1 (NORND)	; ACC2 <= (ACC2>>1);						(IWL:6)
;		MAC.C	ACC0, R2, R8 (SS)	; ACC0 <= ACC0 + (R2 * R8);					(IWL:5+1): Fractional Mode
;		MAS.C	ACC2, R2, R8 (SS)	; ACC2 <= ACC2 - (R2 * R8);					(IWL:5+1): Fractional Mode
;		ST.C	DM(I4+M5), ACC2.M	; s6[jj+ii*2+64] = *(I4+64) <= ACC2.M;		(IWL:6)
;ll6:	ST.C	DM(I4+=M4), ACC0.M	; s6[jj+ii*2   ] = *I4 <= ACC0.M, I4 += 2;	(IWL:6)
;		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s5[0] + jj, jj++;
;ll60:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s6[0] + jj, jj++;
;-------------------------------------------------------------------------------
		LD	CNTR, 2
		LD	I1, 0x500				; I1 = &s5[0]
		CP.C	R22, I1				; backup I1 to R22
		LD	I4, 0x600				; I4 = &s6[0];
		CP.C	R20, I4				; backup I4 to R20
		LD	M1, 4					; for s5[x+ 2] addressing with s5[x] address
		LD	M5, 124					; for s6[x+64] addressing with s6[x] address: modified to (128-M4)
; begin: outer loop
		DO ll60 UNTIL CE
		LD	CNTR, 32
		CP.C	I0, R22				; I0 = &s5[jj]
		LD	M0, 4					; M0 = 4*2 - M1: modified
		LD	I7, 0x800				; I7 = &W[0] 
		LD	M7, 4					; 2*2 (complex pair)
		CP.C	I4, R20				; I4 = &s6[jj]
		LD	M4, 4					; 2*2 (complex pair)
; begin: inner loop
		DO	ll6	UNTIL CE
; 7 instructions in this loop
		LD.C	R0, DM(I0+=M0) || LD.C	R6, DM(I7+=M7)			; R0  <= s5[jj+ii*4] = *I0, I0 += 4 (IWL:5) || R6  <= W(ii*2)_128, I7 += 2 (IWL:0) 
		ASHIFT.C	ACC2, R6, -1 (HI) || CP.C	R4, R0			; ACC2.M <= (R6>>1)	(IWL:1) || R4 <= s5[jj+ii*4] = R0 (IWL:5)
		ASHIFT.C	ACC0, R0, -1 (HI) || CP.C	R6, ACC2.M		; ACC0 <= (R0>>1) (IWL:6) || R6 <= ACC2.M (IWL:1)
		ASHIFT.C	ACC2, R4, -1 (HI) || LD.C	R2, DM(I0+=M1)	; ACC2 <= (R4>>1) (IWL:6) || R2  <= s5[jj+ii*4+2] = *(I0+2) (IWL:5)
		MAC.C	ACC0, R2, R6 (SS)								; ACC0 <= ACC0 + (R2 * R6) (IWL:5+1): Fractional Mode
		MAS.C	ACC2, R2, R6 (SS) || ST.C	DM(I4+=M4), ACC0.M	; ACC2 <= ACC2 - (R2 * R6) (IWL:5+1) || s6[jj+ii*2   ] = *I4 <= ACC0.M, I4 += 2 (IWL:6)
ll6:	ST.C	DM(I4+M5), ACC2.M								; s6[jj+ii*2+64] = *(I4+64) <= ACC2.M (IWL:6)
; end: inner loop
		ADD	R22, R22, 2				; R22 <= R22 + 2 = &s5[0] + jj, jj++;
ll60:	ADD	R20, R20, 2				; R20 <= R20 + 2 = &s6[0] + jj, jj++;
; end: outer loop
;---------------------------------------------------------------------------
; Stage 7: N = 128, r = 0 ~ 63, IWL = 7, W(r)_128
;---------------------------------------------------------------------------
;     for ii=0:63
;       s7(ii+1:64:128,1) = fft2(exp(-j*pi*(0:1)'*ii/64).*s6(ii*2+1:1:ii*2+2,1));
; 		;; s7[ii+ 0] = s6[ii*2+0] + W(r)_128 * s6[ii*2+1];
; 		;; s7[ii+64] = s6[ii*2+0] - W(r)_128 * s6[ii*2+1];
;     end
;     y = s7;
; end
;-------------------------------------------------------------------------------
;		LD	M1, 2					; for s6[x+ 1] addressing with s6[x] address
;;		LD	M5, 128					; for y[x+64] addressing with y[x] address
;		LD	CNTR, 64
;		LD	I0, 0x600				; I0 = &s6[0]
;		LD	M0, 4					; M0 = 2*2 (complex pair)
;		LD	I7, 0x800				; I7 = &W[0] 
;		LD	M7, 2					; 1*2 (complex pair)
;		LD	I4, 0x700				; I4 = &y[0];
;		LD	M4, 2					; 1*2 (complex pair)
;		DO	ll7	UNTIL CE
;; 13 instructions in this innermost loop
;		LD.C	R2, DM(I0+M1)		; R2  <= s6[ii*2+1] = *(I0+1);				(IWL:6)
;		CLRACC.C	ACC0			; ACC0 <= 0					
;		LD.C	ACC0.M, DM(I0+=M0)	; ACC0.M  <= s6[ii*2] = *I0, I0 += 2;		(IWL:6)
;		CP.C	ACC2, ACC0			; ACC2 <= s6[ii*2] = ACC0;					(IWL:6)
;		LD.C	R8, DM(I7+=M7);		; R8  <= W(ii*1)_128, I7 += 1;				(IWL:0)
;		ASHIFT.C	ACC6, R8, -1 (HI)	; ACC6.M <= (R8>>1)						(IWL:1)
;		CP.C	R8, ACC6.M			; R8 <= ACC6.M								(IWL:1)
;		ASHIFT.C	ACC0, ACC0, -1 (NORND)	; ACC0 <= (ACC0>>1);						(IWL:7)
;		ASHIFT.C	ACC2, ACC2, -1 (NORND)	; ACC2 <= (ACC2>>1);						(IWL:7)
;		MAC.C	ACC0, R2, R8 (SS)	; ACC0 <= ACC0 + (R2 * R8);					(IWL:6+1): Fractional Mode
;		MAS.C	ACC2, R2, R8 (SS)	; ACC2 <= ACC2 - (R2 * R8);					(IWL:6+1): Fractional Mode
;		ST.C	DM(I4+M5), ACC2.M	; y[ii*2+64] = *(I4+64) <= ACC2.M;			(IWL:7)
;ll7:	ST.C	DM(I4+=M4), ACC0.M	; y[ii*2   ] = *I4 <= ACC0.M, I4 += 1;		(IWL:7)
;-------------------------------------------------------------------------------
		LD	M1, 2					; for s6[x+ 1] addressing with s6[x] address
		LD	M5, 126					; for y[x+64] addressing with y[x] address: modified to (128-M4)
		LD	CNTR, 64
		LD	I0, 0x600				; I0 = &s6[0]
		LD	M0, 2					; M0 = 2*2 - M1: modified
		LD	I7, 0x800				; I7 = &W[0] 
		LD	M7, 2					; 1*2 (complex pair)
		LD	I4, 0x700				; I4 = &y[0];
		LD	M4, 2					; 1*2 (complex pair)
; begin: inner loop
		DO	ll7	UNTIL CE
; 7 instructions in this loop
		LD.C	R0, DM(I0+=M0) || LD.C	R6, DM(I7+=M7)			; R0  <= s6[ii*2] = *I0, I0 += 64 (IWL:6) || R6  <= W(ii)_128, I7 += 1 (IWL:0) 
		ASHIFT.C	ACC2, R6, -1 (HI) || CP.C	R4, R0			; ACC2.M <= (R6>>1)	(IWL:1) || R4 <= s6[ii*2] = R0 (IWL:6)
		ASHIFT.C	ACC0, R0, -1 (HI) || CP.C	R6, ACC2.M		; ACC0 <= (R0>>1) (IWL:7) || R6 <= ACC2.M (IWL:1)
		ASHIFT.C	ACC2, R4, -1 (HI) || LD.C	R2, DM(I0+=M1)	; ACC2 <= (R4>>1) (IWL:7) || R2  <= s6[ii*2+1] = *(I0+1) (IWL:6)
		MAC.C	ACC0, R2, R6 (SS)								; ACC0 <= ACC0 + (R2 * R6) (IWL:6+1): Fractional Mode
		MAS.C	ACC2, R2, R6 (SS) || ST.C	DM(I4+=M4), ACC0.M	; ACC2 <= ACC2 - (R2 * R6) (IWL:6+1) || s7[ii] = *I4 <= ACC0.M, I4 += 1 (IWL:7)
ll7:	ST.C	DM(I4+M5), ACC2.M								; s7[ii+64] = *(I4+64) <= ACC2.M (IWL:7)
; end: inner loop
;---------------------------------------------------------------------------
; Output: y (IWL = 7) (Note: y = s7)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NOP
NOP
NOP
NOP
NOP
NOP
NOP
NOP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; * Simulator paramters:
;
; dspsim fft128_opt_v2.asm -if fft128_w.dat -of fft128_wout3.dat -oa 000 -os 2304 -c -q >! fft128_opt_v2.dspsim.txt
; binsim fft128_opt_v2.out -if fft128_w.dat -of fft128_wout4.dat -oa 000 -os 2304 -c -q >! fft128_opt_v2.binsim.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; * Simulator version:
;
; dspsim: OFDM DSP Simulator 1.42
; All Rights Reserved.
; Last Built: Jun 19 2009 02:30:21
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; * Simulator output:
;
;----------------------------------
;** Simulator Statistics Summary **
;----------------------------------
; Time: 4083 cycles for 1 iteration
; Overflow: 0 times
;
; * Note: 4531 - 259(Coeff init.) - 8(ending NOPs) = 3816 cycles
;
